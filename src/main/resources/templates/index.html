<!DOCTYPE html SYSTEM "http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset='utf-8' />
    <title>Style circles with a data-driven property</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <link href='//api.tiles.mapbox.com/mapbox-gl-js/v0.44.2/mapbox-gl.css' rel='stylesheet' />
    <style>
        body { margin:0; padding:0; }
        #map { position:absolute; top:0; bottom:0; width:100%; }

        /*#menu {
            background: #fff;
            position: absolute;
            z-index: 1;
            top: 10px;
            right: 10px;
            border-radius: 3px;
            width: 120px;
            border: 1px solid rgba(0,0,0,0.4);
            font-family: 'Open Sans', sans-serif;
        }

        #menu a {
            font-size: 13px;
            color: #404040;
            display: block;
            margin: 0;
            padding: 0;
            padding: 10px;
            text-decoration: none;
            border-bottom: 1px solid rgba(0,0,0,0.25);
            text-align: center;
        }

        #menu a:last-child {
            border: none;
        }

        #menu a:hover {
            background-color: #f8f8f8;
            color: #404040;
        }

        #menu a.active {
            background-color: #3887be;
            color: #ffffff;
        }

        #menu a.active:hover {
            background: #3074a4;
        }*/

        /* features */
        #features {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 300px;
            overflow: auto;
            background: rgba(255, 255, 255, 0.8);
        }

        /* Show drawn polygon area */
        .calculation-box {
            height: 75px;
            width: 150px;
            position: absolute;
            bottom: 40px;
            left: 10px;
            background-color: rgba(255, 255, 255, .9);
            padding: 15px;
            text-align: center;
        }

        p {
            /*font-family: 'Open Sans';*/
            margin: 0;
            font-size: 13px;
        }
    </style>
</head>
<body>

<div id='map'></div>
<!--<nav id="menu"></nav>-->
<pre id='features'></pre>
<div class='calculation-box'>
    <p>Draw a polygon using the draw tools to query.</p>
    <div id='calculated-area'></div>
    <p style="position:absolute;right:0;bottom:0;"><b>Zoom</b> = <span id='zoom-level'></span></p>
</div>

<script src='//api.tiles.mapbox.com/mapbox-gl-js/v0.44.2/mapbox-gl.js'></script>
<script src='//cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.10/Rx.min.js'></script>
<script src='https://api.tiles.mapbox.com/mapbox.js/plugins/turf/v3.0.11/turf.min.js'></script>
<script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.0.0/mapbox-gl-draw.js'></script>
<link rel='stylesheet' href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.0.0/mapbox-gl-draw.css' type='text/css'/>

<script th:inline="javascript">
    /*<![CDATA[*/
    var CONTEXT = '/spewmap/households/api';
    var baseUrl = CONTEXT + '/bbox/';
    var sourceId = 'households';
    var circleId = 'household-as-circle';
    var labelId = 'household-persons';
    var layerIds = [circleId, labelId];
    var subject = new Rx.Subject();
    // var prelenderStyle = 'mapbox://styles/tps23/cjgsfqofv00002qs824xxduyw'; //pa_d16_z16 (density 16, zoom 16) // OK
    // var prelenderStyle = 'mapbox://styles/tps23/cjgsfy5nk000q2rqsgtlg3b8u'; //pa_d18_z14 (density 18, zoom 14) // OK
    // var prelenderStyle  = 'mapbox://styles/tps23/cjgwlt85x00082rtcohcwhqv8'; //wy (density 18, max zoom 14)
    // var prelenderStyle  = 'mapbox://styles/tps23/cjgwlzq0c00092sp5d7r6o2bi'; //wy_pa (density 18, max zoom 14)
    // var prelenderStyle = 'mapbox://styles/tps23/cjgwnskl4000k2sn55fcmtqmx'; //multilayer AL-AK-CA-FL-HA-MA-PA-WY(density 18, max zoom 14)
    var prelenderStyle = 'mapbox://styles/tps23/cjgxy3w95001b2sr3lveze2kq'; //single layer AL-AK-CA-FL-HA-MA-PA-WY(density 18, max zoom 14)


    // var prelenderStyle = 'mapbox://styles/tps23/cjgntk6hs00052rppdqnkmi71'; // PA z12=>16 // Unknow
    // var prelenderStyle = 'mapbox://styles/tps23/cjgwda555000o2rmjoc17f1bs'; //pa_default (zoom 14, density ?)
    // var prelenderStyle = 'mapbox://styles/tps23/cjgsfxlmp00092rl73pk74fek'; //pa_z18 (density ?) //Zoome=3 too many drops
    // var prelenderStyle = 'mapbox://styles/tps23/cjgsg01fw00142rnkk4hz7bu5'; //pa_d20_z8 (density 20, zoom 8) // Zoom=13 too many drops
    // var prelenderStyle = 'mapbox://styles/tps23/cjggv0hzt001h2rlnzo7gy6rk';// WY z10=>20
    // var prelenderStyle = 'mapbox://styles/mapbox/light-v9';

    var emptyGeoJson = {
        type: 'FeatureCollection',
        features:[],
        properties:{note:'dummy GeoJson generated by JavaScript'}
    };

    var hash = toDict(location.hash);
    console.log(hash);
    var m ={
        limit: toNumber(hash, 'limit') || 50000000,
        center: toCenter(hash) || [-107, 43], // USA
        zoom: toNumber(hash, 'zoom') || 3
    };
    console.log(m);

    mapboxgl.accessToken = 'pk.eyJ1Ijoic2FoYXd1dDB5YWhvbyIsImEiOiJjamdjcnRlNmVhMm52MndudnBzcGYxMXM2In0.tunR_ko7G4z0bqKefTs-pw';
    var map = new mapboxgl.Map({
        container: 'map',
        style: prelenderStyle,
        zoom: m.zoom,
        center: m.center
    });
    map.on('load', onLoad);
    map.on('zoomend', onZoomend);
    /*map.on('mousemove', function (e) {
        var features = map.queryRenderedFeatures(e.point);
        document.getElementById('features').innerHTML = JSON.stringify(features, null, 2);
    });*/
    var draw = new MapboxDraw({
        displayControlsDefault: false,
        controls: {
            polygon: true,
            trash: true
        }
    });
    map.addControl(draw, 'bottom-left');

    map.on('draw.create', updateArea);
    map.on('draw.delete', updateArea);
    map.on('draw.update', updateArea);

    function updateArea(e) {
        var featureCollection = draw.getAll();
        var answer = document.getElementById('calculated-area');
        if (featureCollection.features.length > 0) {
            var area = turf.area(featureCollection);
            // restrict to area to 2 decimal points
            var rounded_area = Math.round(area*100)/100;
            answer.innerHTML = '<p><strong>' + rounded_area + '</strong></p><p>square meters</p>';
            //+ '<p><p>geometry</p><strong>' + JSON.stringify(data.features[0].geometry) + '</strong></p>';
            var token = {cancel: function(){}};
            var url = CONTEXT + '/summarize';
            var features = document.getElementById('features');
            var combined = turf.combine(featureCollection);
            var geometry = combined.features[0].geometry;
            features.innerHTML = "<b>Please wait...</b> <br/> <br/>Loading with the below query: <br/>" + JSON.stringify(geometry, null, 1);
            Rx.Observable.fromPromise(postWithCancel(url, token, geometry))
                .subscribe(function (response){
                    console.log(response);
                    features.innerHTML = "<b>Result of the querying polgon(s):</b><br/>" + JSON.stringify(JSON.parse(response), null, 2);
                });
        } else {
            answer.innerHTML = '';
            if (e.type !== 'draw.delete') alert("Use the draw tools to draw a polygon!");
        }
    }

    function onLoad() {
        map.autoLoadHousehold = false;
        addSource(sourceId);
        addCircleLayer(circleId);
        addLabelLayer(labelId);
        initRx(subject);
    }

    function onZoomend(){
        var theZoom = 16; //10;//12;// 16;
        var zoom = map.getZoom();
        swithToInteractiveMode(zoom >= theZoom);
        console.log('zoom=' + zoom + '; bbox='+ JSON.stringify(map.getBounds()));
        var zoomLabel = document.getElementById('zoom-level');
        zoomLabel.innerHTML = zoom.toFixed(5);
    }

    function addLabelLayer(id) {
        map.addLayer({
            id: id,
            type: 'symbol',
            source: sourceId,
            minzoom: 19, //18, //16, //17,// 18,
            layout: {
                // 'icon-image': 'monument-15', // https://github.com/mapbox/mapbox-gl-styles#standard-icons
                'text-allow-overlap': true,
                'text-field': '{persons}',
                'text-offset': [0, 0]
            }
        });
    }

    function addCircleLayer(id) {
        map.addLayer({
            id: id,
            type: 'circle',
            source: sourceId,
            visibility: map.autoLoadHousehold ? 'visible' : 'none',
            paint: {
                'circle-radius': {
                    base: 1.75,
                    stops: [ [16, 2], [22, 40] ]
                },
                'circle-color': 'red' //'orange' //'red'
            },
            filter: ['==', '$type', 'Point']
        });

        map.on('click', id, function (e) {
            var coordinates = e.features[0].geometry.coordinates.slice();
            // Ensure that if the map is zoomed out such that multiple
            // copies of the feature are visible, the popup appears
            // over the copy being pointed to.
            while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
                coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
            }
            new mapboxgl.Popup()
                .setLngLat(coordinates)
                .setHTML(html(e))
                .addTo(map);
        });
        map.on('mouseenter', id, function () {
            map.getCanvas().style.cursor = 'pointer';
        });
        map.on('mouseleave', id, function () {
            map.getCanvas().style.cursor = '';
        });

        function html(e) {
            var obj = e.features[0].properties;
            var html = '';
            for (var k in obj) {
                if (obj.hasOwnProperty(k))
                    html += ' <b>' + k + '</b>:' + obj[k];
            }
            return html;
        }
    }

    function initRx() {
        var mapMoveend = Rx.Observable.fromEvent(map, 'moveend')
            .map(function(event){
                return map.getBounds();
            });
        var userMovedMap = Rx.Observable.merge(subject, mapMoveend);
        var token = {cancel: function(){}};
        userMovedMap
            .debounceTime(1000)
            .switchMap(function (bbox) {
                if (! map.autoLoadHousehold)
                    return Rx.Observable.of(JSON.stringify(emptyGeoJson));
                var csv = toCsv(bbox);
                var url = baseUrl + csv + "?size=" + m.limit;
                token.cancel();
                return Rx.Observable.fromPromise(getWithCancel(url, token));
            })
            .subscribe(function (response){
                geojson = JSON.parse(response);
                var s = map.getSource(sourceId);
                s.setData(geojson);
                console.log('# of houses = ' + geojson.features.length
                    + ' ' + JSON.stringify(geojson.properties));
            });
    }

    function addSource(id) {
        map.addSource(id, {
            type: 'geojson',
            data: emptyGeoJson
        });
    }

    function toCsv(bbox) {
        var e = bbox.getEast();
        var n = bbox.getNorth();
        var w = bbox.getWest();
        var s = bbox.getSouth();
        return e + ',' + n + ',' + w + ',' + s;
    }

    function toDict(query){
        return  query.replace("#", "")
            .split("&")
            .map( function (el) { return el.split("="); })
            .reduce(function (pre, cur) {
                    pre[cur[0]] = cur[1];
                    return pre;
            }, {} );
    }

    function toCenter(hash) {
        var text = hash['center'];
        if (text && text.includes(",")){
            tokens = text.split(",");
            return [tokens[0].valueOf(), tokens[1].valueOf()];
        }
        return null
    }

    function toNumber(hash, key) {
        var text = hash[key];
        if (text){
            var value = text.valueOf();
            var maxValue = 325e4; // 35e5 = crash
            if (value > maxValue){
                console.log("Requested limit=" + value + " is too much; it might crash your browser. Set limit to " + maxValue + " to avoid the crash.");
                return maxValue;
            }
            return value;
        }
        return null;
    }

    function swithToInteractiveMode(flag){
        if (map.autoLoadHousehold === flag)
            return;
        map.autoLoadHousehold = flag;
        for (var i = 0; i < layerIds.length; i++) {
            var id = layerIds[i];
            if (flag === false) {
                map.setLayoutProperty(id, 'visibility', 'none');
                this.className = '';
            } else {
                subject.next(map.getBounds());
                this.className = 'active';
                map.setLayoutProperty(id, 'visibility', 'visible');
            }
        }

    }

    function requestWithCancel(method, url, token, body) {
        var request = new XMLHttpRequest();
        request.open(method, url);
        if (body){
            request.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
            body = JSON.stringify(body);
        }
        request.send(body);
        return new Promise(
            function (resolve, reject) {
                request.onload = function () {
                    resolve(request.responseText);
                };
                token.cancel = function () {
                    request.abort();
                    reject(new Error("Cancelled")); // reject the promise
                };
                request.onerror = reject;
            }
        );
    }

    function getWithCancel(url, token) { // the token is for cancellation
        return requestWithCancel("GET", url, token);
    }

    function postWithCancel(url, token, body) { // the token is for cancellation
        return requestWithCancel("POST", url, token, body);
    }

    /*]]>*/
</script>

</body>
</html>